<!DOCTYPE html>
<!-- saved from url=(0043)https://www.cnblogs.com/zyly/p/9651261.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="origin">
    <meta property="og:description" content="其实在深度学习中我们已经介绍了目标检测和目标识别的概念、为了照顾一些没有学过深度学习的童鞋，这里我重新说明一次：目标检测是用来确定图像上某个区域是否有我们要识别的对象，目标识别是用来判断图片上这个对象">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园</title>
    
    <link rel="shortcut icon" href="https://common.cnblogs.com/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/blog-common.min.css">
    <link id="MainCss" rel="stylesheet" href="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/bundle-red_autumnal_leaves.min.css">
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/bundle-red_autumnal_leaves-mobile.min.css">
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/zyly/rss">
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/zyly/rsd.xml">
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/zyly/wlwmanifest.xml">
    <script src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/f.txt"></script><script src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/pubads_impl_rendering_2019081501.js.下載"></script><script async="" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/analytics.js.下載"></script><script type="text/javascript" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/encoder.js.下載"></script><script src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/jquery-2.2.0.min.js.下載"></script>
    <script src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/blog-common.min.js.下載"></script>
    <script>
        var currentBlogId = 410475;
        var currentBlogApp = 'zyly';
        var cb_enable_mathjax = true;
        var isLogined = false;
    </script>
    <script type="text/x-mathjax-config;executed=true">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/MathJax.js.下載"></script>
    
<link rel="preload" href="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/f(1).txt" as="script"><script type="text/javascript" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/f(1).txt"></script><link rel="preload" href="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/f(2).txt" as="script"><script type="text/javascript" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/f(2).txt"></script><script src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/pubads_impl_2019081501.js.下載" async=""></script><link rel="prefetch" href="https://tpc.googlesyndication.com/safeframe/1-0-35/html/container.html"><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/zyly/"><img id="blogLogo" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/logo.gif" alt="返回主页"></a>		
		
<!--done-->
<h1>
<a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/zyly/">大奥特曼打小怪兽</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/zyly/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E5%A4%A7%E5%A5%A5%E7%89%B9%E6%9B%BC%E6%89%93%E5%B0%8F%E6%80%AA%E5%85%BD">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/zyly/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
128&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
98</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class="postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/zyly/p/9651261.html">第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码)</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body "><a name="_labelTop"></a><div id="navCategory" style="color:#152e97;"><p style="font-size:18px;"><b>目录</b></p><ul><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label0">一 HOG</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1">二 算法的具体实现</a><ul><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1_0">1、图像标准化(调节图像的对比度)</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1_1">2、图像平滑(具体视情况而定)</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1_2">3、边缘方向计算</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1_3">4、直方图计算</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1_4">5、对block归一化</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1_5">6、样本HOG特征提</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label1_6">7、行人检测HOG+SVM</a></li></ul></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label2">三&nbsp; 手动实现HOG特征</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label3">&nbsp;四 目标检测中的问题</a><ul><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label3_0">1、图像金字塔</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label3_1">2、滑动窗口</a></li></ul></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label4">五 使用opencv检测人</a></li><li><a href="https://www.cnblogs.com/zyly/p/9651261.html#_label5">六 总结</a></li></ul></div><p>&nbsp;</p><hr style="height:1px;border:none;border-top:1px dashed #0066CC;">
    <p>其实在深度学习中我们已经介绍了目标检测和目标识别的概念、为了照顾一些没有学过深度学习的童鞋，这里我重新说明一次：目标检测是用来确定图像上某个区域是否有我们要识别的对象，目标识别是用来判断图片上这个对象是什么。识别通常只处理已经检测到对象的区域，例如，人们总是会在已有的人脸图像的区域去识别人脸。</p>
<p>传统的目标检测方法与识别不同于深度学习方法，后者主要利用神经网络来实现分类和回归问题。在这里我们主要介绍如何利用OpecnCV来实现传统目标检测和识别，在计算机视觉中有很多目标检测和识别的技术，这里我们主要介绍下面几块内容：</p>
<ul>
<li>方向梯度直方图HOG(Histogram of Oriented Gradient)；</li>
<li>图像金字塔；</li>
<li>滑动窗口；</li>
</ul>
<p>上面这三块内容其实后面两块我们之前都已经介绍过，由于内容也比较多，这里不会比较详细详细介绍，下面我们从HOG说起。</p>
<div style="text-align: right;"><a href="https://www.cnblogs.com/zyly/p/9651261.html#_labelTop" style="color:#f68a33">回到顶部</a><a name="_label0"></a></div><h3>一 HOG</h3>
<p>HOG特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子，是与SIFT、SURF、ORB属于同一类型的描述符。HOG不是基于颜色值而是基于梯度来计算直方图的，它通过计算和统计图像局部区域的梯度方向直方图来构建特征。HOG特征结合SVM分类器已经被广泛应用到图像识别中，尤其在行人检测中获得了极大的成功。</p>
<p><strong>1、主要思想</strong></p>
<p>此方法的基本观点是：局部目标的外表和形状可以被局部梯度或边缘方向的分布很好的描述，即使我们不知道对应的梯度和边缘的位置。(本质：梯度的统计信息，梯度主要存在于边缘的地方)</p>
<p><strong>2、实施方法</strong></p>
<p>首先将图像分成很多小的连通区域，我们把它叫做细胞单元，然后采集细胞单元中各像素点的梯度和边缘方向，然后在每个细胞单元中累加出一个一维的梯度方向直方图。</p>
<p>为了对光照和阴影有更好的不变性，需要对直方图进行对比度归一化，这可以通过把这些直方图在图像的更大的范围内(我们把它叫做区间或者block)进行对比度归一化。首先我们计算出各直方图在这个区间中的密度，然后根据这个密度对区间中的各个细胞单元做归一化。我们把归一化的块描述符叫作HOG描述子。</p>
<p><strong>3、目标检测</strong></p>
<p>将检测窗口中的所有块的HOG描述子组合起来就形成了最终的特征向量，然后使用SVM分类器进行行人检测。下图描述了特征提取和目标检测流程。检测窗口划分为重叠的块，对这些块计算HOG描述子，形成的特征向量放到线性SVM中进行目标/非目标的二分类。<span style="color: #ff0000;">检测窗口在整个图像的所有位置和尺度上进行扫描，并对输出的金字塔进行非极大值抑制来检测目标。<span style="color: #000000;">(检测窗口的大小一般为$128\times{64}$)</span></span></p>
<p><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180917143312309-1232187669.png" alt=""></p>
<div style="text-align: right;"><a href="https://www.cnblogs.com/zyly/p/9651261.html#_labelTop" style="color:#f68a33">回到顶部</a><a name="_label1"></a></div><h3>二 算法的具体实现</h3>
<a name="_label1_0"></a><h4>1、图像标准化(调节图像的对比度)</h4>
<p>为了减少光照因素的影响，降低图像局部的阴影和光照变化所造成的影响，我们首先采用Gamma校正法对输入图像的颜色空间进行标准化(或者说是归一化)。</p>
<p>所谓的Gamma校正可以理解为提高图像中偏暗或者偏亮部分的图像对比效果，能够有效地降低图像局部的阴影和光照变化。更详细的内容可以点击这里查看<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/qiqibaby/p/5325193.html" target="_blank">图像处理之gamma校正。</a></p>
<p>Gamma校正公式为：</p>
<p>$$f(I)=I^\gamma$$</p>
<p>其中$I$为图像像素值，$\gamma$为Gamma校正系数。$\gamma$系数设定影响着图像的调整效果，结合下图，我们来看一下Gamma校正的作用：</p>
<p><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180917152940250-1871669245.png" alt=""></p>
<p><span id="MathJax-Element-1-Frame">$\gamma&lt;1$在低灰度值区域内，动态范围变大，图像对比度增加强；在高灰度值区域，动态范围变小，图像对比度降低，同时，图像的整体灰度值变大；</span></p>
<p><span id="MathJax-Element-1-Frame">$\gamma&gt;1$在低灰度值区域内，动态范围变小，图像对比度降低；<span id="MathJax-Element-1-Frame">在高灰度值区域，动态范围变大，图像对比度提高</span>，<span id="MathJax-Element-1-Frame">同时，图像的整体灰度值变小；</span></span></p>
<p>&nbsp;<img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180917222438706-1416047027.png" alt=""></p>
<p><span style="color: #000000;">左边的图像为原图，中间图像的$\gamma=\frac{1}{2.2}$，右图$\gamma=2.2$。</span></p>
<p><span class="MathJax_Preview" style="color: #000000;"><span id="MathJax-Element-1-Frame" class="MathJax">作者在他的博士论文里有提到，对于涉及大量的类内颜色变化，如猫，狗和马等动物，没标准化的RGB图效果更好，而牛，羊的图做gamma颜色校正后效果更好。是否用gamma校正得分析具体的训练集情况。</span></span></p>
<a name="_label1_1"></a><h4><strong>2、图像平滑(具体视情况而定)</strong></h4>
<p><span class="MathJax_Preview" style="color: #000000;"><span class="MathJax">对于灰度图像，一般为了去除噪点，所以会先利用高斯函数进行平滑：高斯函数在不同的平滑尺度下对灰度图像进行平滑操作。Dalal等实验表明moving from σ=0 to σ=2 reduces the recall rate from 89% to 80% at</span></span>&nbsp;<span id="MathJax-Element-2-Frame"><span id="MathJax-Span-11"><span id="MathJax-Span-12"><span id="MathJax-Span-13"><span id="MathJax-Span-14">10<span id="MathJax-Span-15"><span id="MathJax-Span-16"><span id="MathJax-Span-17">?<span id="MathJax-Span-18">4&nbsp;FPPW，即不做高斯平滑人体检测效果最佳，使得漏检率缩小了约一倍。不做平滑操作，可能原因：HOG特征是基于边缘的，平滑会降低边缘信息的对比度，从而减少图像中的有用信息。</span></span></span></span></span></span></span></span></span></p>
<a name="_label1_2"></a><h4><strong>3、边缘方向计算</strong></h4>
<p>&nbsp;计算图像每个像素点的梯度、包括方向和大小：</p>
<p>$$G_x(x,y)=I(x+1,y)-I(x-1,y)$$</p>
<p>$$G_y(x,y)=I(x,y+1)-I(x,y-1)$$</p>
<p>上式中$G_x(x,y)、G_y(x,y)$<span id="MathJax-Element-3-Frame">分别表示输入图像在像素点$(x,y)$处的水平方向梯度和垂直方向梯度，<span id="MathJax-Element-3-Frame"><span id="MathJax-Element-4-Frame">像素点在$(x,y)$的梯度幅值和梯度方向</span></span>分别为：</span></p>
<p>$$G(x,y)=\sqrt{G_x(x,y)^2+G_y(x,y)^2}$$</p>
<p>$$\alpha=arctan\frac{G_y(x,y)}{G_x(x,y)}$$</p>
<a name="_label1_3"></a><h4><span id="MathJax-Element-3-Frame"><span id="MathJax-Element-4-Frame">4、直方图计算</span></span></h4>
<p>将图像划分成小的细胞单元(细胞单元可以是矩形的或者环形的)，比如大小为$8\times{8}$，然后统计每一个细胞单元的梯度直方图，即可以得到一个细胞单元的描述符，将几个细胞单元组成一个block，例如$2\times{2}$个细胞单元组成一个block，将一个block内每个细胞单元的描述符串联起来即可以得到一个block的HOG描述符。</p>
<p>在说到统计一个细胞单元的梯度直方图时，我们一般考虑采用9个bin的直方图来统计这$8\times{8}$个像素的梯度信息，即将cell的梯度方向0~180°(或0~360°，即考虑了正负)分成9个方向块，如下图所示：</p>
<p>&nbsp;<img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180924102118644-1581592834.png" alt="" width="420" height="215"></p>
<p>如果cell中某一个像素的梯度方向是20~40°，直方图第2个bin的计数就要加1，这样对cell中的每一个像素用梯度方向在直方图中进行加权投影(权值大小等于梯度幅值)，将其映射到对应的角度范围块内，就可以得到这个cell的梯度方向直方图了，就是该cell对应的9维特征向量。对于梯度方向位于相邻bin的中心之间(如20°、40°等)需要进行方向和位置上的双线性插值。</p>
<p>采用梯度幅值量级本身得到的检测效果最佳，而使用二值的边缘权值表示会严重降低效果。采用梯度幅值作为权重，可以使那些比较明显的边缘的方向信息对特征表达影响增大，这样比较合理，因为HOG特征主要就是依靠这些边缘纹理。</p>
<p>根据Dalal等人的实验，在行人目标检测中，在无符号方向角度范围并将其平均分成9份（bins）能取得最好的效果，当bin的数目继续增大效果改变不明显，故一般在人体目标检测中使用bin数目为9范围0~180°的度量方式。</p>
<a name="_label1_4"></a><h4>5、对block归一化</h4>
<p>由于局部光照的变化，以及前景背景对比度的变化，使得梯度强度的变化范围非常大，这就需要对梯度做局部对比度归一化。归一化能够进一步对光照、阴影、边缘进行压缩，使得特征向量对光照、阴影和边缘变化具有鲁棒性。</p>
<p>具体的做法：将细胞单元组成更大的空间块(block)，然后针对每个块进行对比度归一化。最终的描述子是检测窗口内所有块内的细胞单元的直方图构成的向量。事实上，块之间是有重叠的，也就是说，每个细胞单元的直方图都会被多次用于最终的描述子的计算。块之间的重叠看起来有冗余，但可以显著的提升性能 。</p>
<p><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180924125126990-417946699.png" alt="" width="628" height="225"></p>
<p>通常使用的HOG结构大致有三种：矩形HOG（简称为R-HOG），圆形HOG和中心环绕HOG。它们的单位都是Block（即块）。Dalal的试验证明矩形HOG和圆形HOG的检测效果基本一致，而环绕形HOG效果相对差一些。</p>
<p>&nbsp;<img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180924134436957-853819777.png" alt=""></p>
<p>如上图，一个块由$2\times{2}$个cell组成，每一个cell包含$8\times{8}$个像素点，每个cell提取9个直方图通道，因此一个块的特征向量长度为$2\times{2}\times{9}$。</p>
<p>假设$v$是未经归一化的特征向量。 $\|v\|_k$是$v$的$k$范数，$k=1,2$，是一个很小的常数，对块的特征向量进行归一化，一般有以下四种方法：</p>
<ul>
<li>$L_2-norm$：$v←\frac{v}{\sqrt{\|v\|_2^2+\xi^2}}$($\xi$是一个很小的数，主要是为了防止分母为0)；</li>
<li>$L_2-Hys$：先计算$L_2$范数，然后限制$v$的最大值为0.2，再进行归一化；</li>
<li>$L_1-norm$：$v←\frac{v}{|v\|_1+\xi}$;</li>
<li>$L_1-sqrt$：$v←\sqrt{\frac{v}{\|v\|_1+\xi}}$;</li>
</ul>
<p>在人体检测系统中进行HOG计算时一般使用$L_2-norm$，Dalal的文章也验证了对于人体检测系统使用$L_2-norm$的时候效果最好。</p>
<a name="_label1_5"></a><h4>6、样本HOG特征提</h4>
<p>最后一步就是对一个样本中所有的块进行HOG特征的手机，并将它们结合成最终的特征向量送入分类器。</p>
<p>那么一个样本可以提取多少个特征呢？之前我们已经说过HOG特征的提取过程：</p>
<ul>
<li>首先把样本图片分割为若干个像素的单元，然后把梯度方向划分为9个区间，在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量；</li>
<li>每相邻4个单元构成一个块，把一个块内的特征向量串联起来得到一个36维的特征向量；</li>
<li>用块对样本图像进行扫描，扫描步长为一个单元的大小，最后将所有的块的特征串联起来，就得到一个样本的特征向量；</li>
</ul>
<p>例如：对于$128\times{64}$的输入图片(后面我所有提到的图像大小指的是$h\times{w}$)，每个块由$2\times{2}$个cell组成，每个cell由$8\times{8}$个像素点组成，每个cell提取9个bin大小的直方图，以1个cell大小为步长，那么水平方向有7个扫描窗口，垂直方向有5个扫描窗口，也就是说，一共有$15*7*2*2*9=3780$个特征。</p>
<a name="_label1_6"></a><h4>7、行人检测HOG+SVM</h4>
<p>这里我们介绍一下Dalal等人的训练方法：</p>
<ol>
<li>提取正负样本的HOG特征；</li>
<li>用正负样本训练一个初始的分类器，然后由分类器生产检测器；</li>
<li>然后用初始分类器在负样本原图上进行行人检测，检测出来的矩形区域自然都是分类错误的负样本，这就是所谓的难例(hard examples)；</li>
<li>提取难例的HOG特征并结合第一步中的特征，重新训练，生成最终的检测器 ；</li>
</ol>
<p>这种二次训练的处理过程显著提高了每个检测器的表现，一般可以使得每个窗口的误报率(FPPW False Positives Per Window)下降5%。</p>
<div style="text-align: right;"><a href="https://www.cnblogs.com/zyly/p/9651261.html#_labelTop" style="color:#f68a33">回到顶部</a><a name="_label2"></a></div><h3>三&nbsp; 手动实现HOG特征</h3>
<p>虽然opencv已经实现了HOG算法，但是手动实现的目的是为了加深我们对HOG的理解，本代码参考了博客<a href="https://blog.csdn.net/ppp8300885/article/details/71078555" target="_blank">80行Python实现-HOG梯度特征提取</a>并做了一些调整：</p>
<p>代码主要包括以下步骤：</p>
<ol>
<li>图像灰度化，归一化处理；</li>
<li>首先计算图像每一个像素点的梯度幅值和角度；</li>
<li>计算输入图像的每个cell单元的梯度直方图(注意，我们在实现梯度直方图的时候，使用到的是双线性插值，这和上面介绍的理论略微有区别)，形成每个cell的descriptor，比如输入图像为$128\times{64}$ 可以得到$16\times{8}$个cell，每个cell由9个bin组成；</li>
<li>将$2\times{2}$个cell组成一个block，一个block内所有cell的特征串联起来得到该block的HOG特征descriptor，并进行归一化处理，将图像内所有block的HOG特征descriptor串联起来得到该图像的HOG特征descriptor，这就是最终分类的特征向量；</li>
</ol>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> -*- coding: utf-8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">
Created on Mon Sep 24 18:23:04 2018

@author: zy
</span><span style="color: #800000;">"""</span>

<span style="color: #008000;">#</span><span style="color: #008000;">代码来源GitHub:https://github.com/PENGZhaoqing/Hog-feature</span><span style="color: #008000;">
#</span><span style="color: #008000;">https://blog.csdn.net/ppp8300885/article/details/71078555</span><span style="color: #008000;">
#</span><span style="color: #008000;">https://www.leiphone.com/news/201708/ZKsGd2JRKr766wEd.html</span>

<span style="color: #0000ff;">import</span><span style="color: #000000;"> cv2
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> numpy as np
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> math
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> matplotlib.pyplot as plt


</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Hog_descriptor():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    HOG描述符的实现
    </span><span style="color: #800000;">'''</span>
    <span style="color: #0000ff;">def</span> <span style="color: #800080;">__init__</span>(self, img, cell_size=8, bin_size=9<span style="color: #000000;">):
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        构造函数
            默认参数，一个block由2x2个cell组成，步长为1个cell大小 
        args:
            img：输入图像(更准确的说是检测窗口)，这里要求为灰度图像  对于行人检测图像大小一般为128x64 即是输入图像上的一小块裁切区域
            cell_size：细胞单元的大小 如8，表示8x8个像素
            bin_size：直方图的bin个数
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        self.img </span>=<span style="color: #000000;"> img
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        采用Gamma校正法对输入图像进行颜色空间的标准化（归一化），目的是调节图像的对比度，降低图像局部
        的阴影和光照变化所造成的影响，同时可以抑制噪音。采用的gamma值为0.5。 f(I)=I^γ
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        self.img </span>= np.sqrt(img*1.0 /<span style="color: #000000;"> float(np.max(img)))
        self.img </span>= self.img * 255
        <span style="color: #008000;">#</span><span style="color: #008000;">print('img',self.img.dtype)   #float64</span>
        <span style="color: #008000;">#</span><span style="color: #008000;">参数初始化</span>
        self.cell_size =<span style="color: #000000;"> cell_size
        self.bin_size </span>=<span style="color: #000000;"> bin_size
        self.angle_unit </span>= 180 / self.bin_size  <span style="color: #008000;">#</span><span style="color: #008000;">这里采用180°</span>
        <span style="color: #0000ff;">assert</span> type(self.bin_size) == int, <span style="color: #800000;">"</span><span style="color: #800000;">bin_size should be integer,</span><span style="color: #800000;">"</span>
        <span style="color: #0000ff;">assert</span> type(self.cell_size) == int, <span style="color: #800000;">"</span><span style="color: #800000;">cell_size should be integer,</span><span style="color: #800000;">"</span>
        <span style="color: #0000ff;">assert</span> 180 % self.bin_size == 0, <span style="color: #800000;">"</span><span style="color: #800000;">bin_size should be divisible by 180</span><span style="color: #800000;">"</span>

    <span style="color: #0000ff;">def</span><span style="color: #000000;"> extract(self):
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        计算图像的HOG描述符，以及HOG-image特征图
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        height, width </span>=<span style="color: #000000;"> self.img.shape
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        1、计算图像每一个像素点的梯度幅值和角度
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        gradient_magnitude, gradient_angle </span>=<span style="color: #000000;"> self.global_gradient()
        gradient_magnitude </span>=<span style="color: #000000;"> abs(gradient_magnitude)
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        2、计算输入图像的每个cell单元的梯度直方图，形成每个cell的descriptor 比如输入图像为128x64 可以得到16x8个cell，每个cell由9个bin组成
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        cell_gradient_vector </span>= np.zeros((int(height / self.cell_size), int(width /<span style="color: #000000;"> self.cell_size), self.bin_size))
        </span><span style="color: #008000;">#</span><span style="color: #008000;">遍历每一行、每一列</span>
        <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(cell_gradient_vector.shape[0]):
            </span><span style="color: #0000ff;">for</span> j <span style="color: #0000ff;">in</span> range(cell_gradient_vector.shape[1<span style="color: #000000;">]):
                </span><span style="color: #008000;">#</span><span style="color: #008000;">计算第[i][j]个cell的特征向量</span>
                cell_magnitude = gradient_magnitude[i * self.cell_size:(i + 1) *<span style="color: #000000;"> self.cell_size,
                                 j </span>* self.cell_size:(j + 1) *<span style="color: #000000;"> self.cell_size]
                cell_angle </span>= gradient_angle[i * self.cell_size:(i + 1) *<span style="color: #000000;"> self.cell_size,
                             j </span>* self.cell_size:(j + 1) *<span style="color: #000000;"> self.cell_size]
                cell_gradient_vector[i][j] </span>=<span style="color: #000000;"> self.cell_gradient(cell_magnitude, cell_angle)

        </span><span style="color: #008000;">#</span><span style="color: #008000;">将得到的每个cell的梯度方向直方图绘出，得到特征图</span>
        hog_image =<span style="color: #000000;"> self.render_gradient(np.zeros([height, width]), cell_gradient_vector)
        
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        3、将2x2个cell组成一个block，一个block内所有cell的特征串联起来得到该block的HOG特征descriptor
           将图像image内所有block的HOG特征descriptor串联起来得到该image（检测目标）的HOG特征descriptor，
           这就是最终分类的特征向量
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        hog_vector </span>=<span style="color: #000000;"> []
        </span><span style="color: #008000;">#</span><span style="color: #008000;">默认步长为一个cell大小，一个block由2x2个cell组成，遍历每一个block</span>
        <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span> range(cell_gradient_vector.shape[0] - 1<span style="color: #000000;">):
            </span><span style="color: #0000ff;">for</span> j <span style="color: #0000ff;">in</span> range(cell_gradient_vector.shape[1] - 1<span style="color: #000000;">):
                </span><span style="color: #008000;">#</span><span style="color: #008000;">提取第[i][j]个block的特征向量</span>
                block_vector =<span style="color: #000000;"> []
                block_vector.extend(cell_gradient_vector[i][j])
                block_vector.extend(cell_gradient_vector[i][j </span>+ 1<span style="color: #000000;">])
                block_vector.extend(cell_gradient_vector[i </span>+ 1<span style="color: #000000;">][j])
                block_vector.extend(cell_gradient_vector[i </span>+ 1][j + 1<span style="color: #000000;">])
                </span><span style="color: #800000;">'''</span><span style="color: #800000;">块内归一化梯度直方图，去除光照、阴影等变化，增加鲁棒性</span><span style="color: #800000;">'''</span>
                <span style="color: #008000;">#</span><span style="color: #008000;">计算l2范数</span>
                mag = <span style="color: #0000ff;">lambda</span> vector: math.sqrt(sum(i ** 2 <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> vector))   
                magnitude </span>= mag(block_vector) + 1e-5
                <span style="color: #008000;">#</span><span style="color: #008000;">归一化</span>
                <span style="color: #0000ff;">if</span> magnitude !=<span style="color: #000000;"> 0:
                    normalize </span>= <span style="color: #0000ff;">lambda</span> block_vector, magnitude: [element / magnitude <span style="color: #0000ff;">for</span> element <span style="color: #0000ff;">in</span><span style="color: #000000;"> block_vector]
                    block_vector </span>=<span style="color: #000000;"> normalize(block_vector, magnitude)
                hog_vector.append(block_vector)           
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> np.asarray(hog_vector), hog_image

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> global_gradient(self):
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        分别计算图像沿x轴和y轴的梯度
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        gradient_values_x </span>= cv2.Sobel(self.img, cv2.CV_64F, 1, 0, ksize=5<span style="color: #000000;">)
        gradient_values_y </span>= cv2.Sobel(self.img, cv2.CV_64F, 0, 1, ksize=5<span style="color: #000000;">)
        </span><span style="color: #008000;">#</span><span style="color: #008000;">计算梯度幅值 这个计算的是0.5*gradient_values_x + 0.5*gradient_values_y</span>
        <span style="color: #008000;">#</span><span style="color: #008000;">gradient_magnitude = cv2.addWeighted(gradient_values_x, 0.5, gradient_values_y, 0.5, 0)</span>
        <span style="color: #008000;">#</span><span style="color: #008000;">计算梯度方向</span>
        <span style="color: #008000;">#</span><span style="color: #008000;">gradient_angle = cv2.phase(gradient_values_x, gradient_values_y, angleInDegrees=True)</span>
        gradient_magnitude, gradient_angle = cv2.cartToPolar(gradient_values_x,gradient_values_y,angleInDegrees=<span style="color: #000000;">True)        
        </span><span style="color: #008000;">#</span><span style="color: #008000;">角度大于180°的，减去180度</span>
        gradient_angle[gradient_angle&gt;180.0] -= 180 
        <span style="color: #008000;">#</span><span style="color: #008000;">print('gradient',gradient_magnitude.shape,gradient_angle.shape,np.min(gradient_angle),np.max(gradient_angle))</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> gradient_magnitude, gradient_angle

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> cell_gradient(self, cell_magnitude, cell_angle):
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        为每个细胞单元构建梯度方向直方图
        
        args:
            cell_magnitude：cell中每个像素点的梯度幅值
            cell_angle：cell中每个像素点的梯度方向
        return：
            返回该cell对应的梯度直方图，长度为bin_size
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        orientation_centers </span>= [0] *<span style="color: #000000;"> self.bin_size
        </span><span style="color: #008000;">#</span><span style="color: #008000;">遍历cell中的每一个像素点</span>
        <span style="color: #0000ff;">for</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(cell_magnitude.shape[0]):
            </span><span style="color: #0000ff;">for</span> j <span style="color: #0000ff;">in</span> range(cell_magnitude.shape[1<span style="color: #000000;">]):
                </span><span style="color: #008000;">#</span><span style="color: #008000;">梯度幅值</span>
                gradient_strength =<span style="color: #000000;"> cell_magnitude[i][j]
                </span><span style="color: #008000;">#</span><span style="color: #008000;">梯度方向</span>
                gradient_angle =<span style="color: #000000;"> cell_angle[i][j]
                </span><span style="color: #008000;">#</span><span style="color: #008000;">双线性插值</span>
                min_angle, max_angle, weight =<span style="color: #000000;"> self.get_closest_bins(gradient_angle)
                orientation_centers[min_angle] </span>+= (gradient_strength * (1 -<span style="color: #000000;"> weight))
                orientation_centers[max_angle] </span>+= (gradient_strength *<span style="color: #000000;">weight)
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> orientation_centers

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> get_closest_bins(self, gradient_angle):
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        计算梯度方向gradient_angle位于哪一个bin中，这里采用的计算方式为双线性插值
        具体参考：https://www.leiphone.com/news/201708/ZKsGd2JRKr766wEd.html
        例如：当我们把180°划分为9个bin的时候，分别对应对应0,20,40,...160这些角度。
              角度是10，副值是4，因为角度10介于0-20度的中间(正好一半)，所以把幅值
              一分为二地放到0和20两个bin里面去。
        args:
            gradient_angle:角度
        return：
            start,end,weight：起始bin索引，终止bin的索引，end索引对应bin所占权重
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        idx </span>= int(gradient_angle /<span style="color: #000000;"> self.angle_unit)
        mod </span>= gradient_angle %<span style="color: #000000;"> self.angle_unit
        </span><span style="color: #0000ff;">return</span> idx % self.bin_size, (idx + 1) % self.bin_size, mod /<span style="color: #000000;"> self.angle_unit

    </span><span style="color: #0000ff;">def</span><span style="color: #000000;"> render_gradient(self, image, cell_gradient):
        </span><span style="color: #800000;">'''</span><span style="color: #800000;">
        将得到的每个cell的梯度方向直方图绘出，得到特征图
        args：
            image：画布,和输入图像一样大 [h,w]
            cell_gradient：输入图像的每个cell单元的梯度直方图,形状为[h/cell_size,w/cell_size,bin_size]
        return：
            image：特征图
        </span><span style="color: #800000;">'''</span><span style="color: #000000;">
        cell_width </span>= self.cell_size / 2<span style="color: #000000;">
        max_mag </span>=<span style="color: #000000;"> np.array(cell_gradient).max()
        </span><span style="color: #008000;">#</span><span style="color: #008000;">遍历每一个cell</span>
        <span style="color: #0000ff;">for</span> x <span style="color: #0000ff;">in</span><span style="color: #000000;"> range(cell_gradient.shape[0]):
            </span><span style="color: #0000ff;">for</span> y <span style="color: #0000ff;">in</span> range(cell_gradient.shape[1<span style="color: #000000;">]):
                </span><span style="color: #008000;">#</span><span style="color: #008000;">获取第[i][j]个cell的梯度直方图</span>
                cell_grad =<span style="color: #000000;"> cell_gradient[x][y]
                </span><span style="color: #008000;">#</span><span style="color: #008000;">归一化</span>
                cell_grad /=<span style="color: #000000;"> max_mag
                angle </span>=<span style="color: #000000;"> 0
                angle_gap </span>=<span style="color: #000000;"> self.angle_unit
                </span><span style="color: #008000;">#</span><span style="color: #008000;">遍历每一个bin区间</span>
                <span style="color: #0000ff;">for</span> magnitude <span style="color: #0000ff;">in</span><span style="color: #000000;"> cell_grad:
                    </span><span style="color: #008000;">#</span><span style="color: #008000;">转换为弧度</span>
                    angle_radian =<span style="color: #000000;"> math.radians(angle)
                    </span><span style="color: #008000;">#</span><span style="color: #008000;">计算起始坐标和终点坐标，长度为幅值(归一化),幅值越大、绘制的线条越长、越亮</span>
                    x1 = int(x * self.cell_size + cell_width + magnitude * cell_width *<span style="color: #000000;"> math.cos(angle_radian))
                    y1 </span>= int(y * self.cell_size + cell_width + magnitude * cell_width *<span style="color: #000000;"> math.sin(angle_radian))
                    x2 </span>= int(x * self.cell_size + cell_width - magnitude * cell_width *<span style="color: #000000;"> math.cos(angle_radian))
                    y2 </span>= int(y * self.cell_size + cell_width - magnitude * cell_width *<span style="color: #000000;"> math.sin(angle_radian))
                    cv2.line(image, (y1, x1), (y2, x2), int(</span>255 *<span style="color: #000000;"> math.sqrt(magnitude)))
                    angle </span>+=<span style="color: #000000;"> angle_gap
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> image

        
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span> == <span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    </span><span style="color: #008000;">#</span><span style="color: #008000;">加载图像</span>
    img = cv2.imread(<span style="color: #800000;">'</span><span style="color: #800000;">./image/person.jpg</span><span style="color: #800000;">'</span><span style="color: #000000;">)        
    width </span>= 64<span style="color: #000000;">
    height </span>= 128<span style="color: #000000;">
    img_copy </span>= img[320:320+height,570:570+width][:,:,::-1<span style="color: #000000;">]    
    gray_copy </span>=<span style="color: #000000;"> cv2.cvtColor(img_copy,cv2.COLOR_BGR2GRAY)
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;">显示原图像</span>
    plt.figure(figsize=(6.4,2.0*3.2<span style="color: #000000;">))
    plt.subplot(</span>1,2,1<span style="color: #000000;">)
    plt.imshow(img_copy)
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;">HOG特征提取</span>
    hog = Hog_descriptor(gray_copy, cell_size=8, bin_size=9<span style="color: #000000;">)    
    hog_vector, hog_image </span>=<span style="color: #000000;"> hog.extract()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hog_vector</span><span style="color: #800000;">'</span><span style="color: #000000;">,hog_vector.shape)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">hog_image</span><span style="color: #800000;">'</span><span style="color: #000000;">,hog_image.shape)
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;">绘制特征图</span>
    plt.subplot(1,2,2<span style="color: #000000;">)
    plt.imshow(hog_image, cmap</span>=<span style="color: #000000;">plt.cm.gray)    
    plt.show()</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>程序运行结果为：</p>
<p><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180924213826889-1872377797.png" alt=""></p>
<p>我们可以看到当输入图像大小为$128\times{64}$时，得到的HOG特征向量为$105\times{36}=3780$，这和我们计算的一样，左边的图为需要提取HOG特征的原图，右图为所提取得到的特征图，我们使用线段长度表示每一个cell中每一个bin的幅值大小(同时线段的亮度也与幅值大小成正比)，线段倾斜角度表示cell中每一个bin的角度，从右图上我们可以大致观察到这个人的边缘信息以及梯度变化，因此利用该特征可以很容易的识别出人的主要结构。</p>
<div style="text-align: right;"><a href="https://www.cnblogs.com/zyly/p/9651261.html#_labelTop" style="color:#f68a33">回到顶部</a><a name="_label3"></a></div><h3>&nbsp;四 目标检测中的问题</h3>
<p>虽然我们已经介绍了HOG特征的提取，但是在想把HOG特征应用到目标检测上，我们还需考虑两个问题：</p>
<ul>
<li><strong>尺度</strong>：对于这个问题可以通过举例说明：假如要检测的目标(比如人)是较大图像中的一部分，要把要检测的图像和训练图像比较。如果在比较中找不到一组相同的梯度，则检测就会失败(即使两张图像都有人)。</li>
<li><strong>位置</strong>：在解决了尺度问题后，还有另一个问题：要检测的目标可能位于图像上的任一个地方，所以需要扫描图像的每一个地方，以取保找到感兴趣的区域，并且尝试在这些区域检测目标。即使待检测的图像中的目标和训练图像中的目标一样大，也需要通过某种方式让opencv定位该目标。</li>
</ul>
<a name="_label3_0"></a><h4>1、图像金字塔</h4>
<p>图像金字塔有助于解决不同尺度下的目标检测问题，图像金字塔使图像的多尺度表示，如下图所示：</p>
<p><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180924221334307-1701938273.png" alt="" width="394" height="260"></p>
<p>构建图像金字塔一般包含以下步骤(详细内容可以参考<a href="https://www.cnblogs.com/ronny/p/3886013.html" target="_blank">尺度空间理论</a>）：</p>
<ol>
<li>获取图像；</li>
<li>使用任意尺度的参数来调整(缩小)图像的大小；</li>
<li>平滑图像(使用高斯模糊)；</li>
<li>如果图像比最小尺度还大，从第一步开会重复这个过程；</li>
</ol>
<p>在<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/zyly/p/9410563.html" target="_blank">人脸检测之Haar分类器</a>这一节我们利用haar特征和级联分类器Adaboost检测人脸时我们使用过一个函数detectMultiScale()，这个函数就涉及这些内容，级联分类器对象尝试在输入图像的不同尺度下检测对象，该函数有一个比较重要的参数scaleFactor(一般设置为1.3)，表示一个比率：即在每层金字塔中所获得的图像与上一层图像的比率，scaleFactor越小，金字塔的层数就越多，计算就越慢，计算量也会更大，但是计算结果相对更精确。</p>
<p>下面我们在对人进行检测时候也会再次使用到这个函数。</p>
<a name="_label3_1"></a><h4>2、滑动窗口</h4>
<p>滑动窗口是用在计算机视觉的一种技术，它包括图像中要移动部分(滑动窗口)的检查以及使用图像金字塔对各部分进行检测。这是为了在多尺度下检测对象。</p>
<p>滑动窗口通过扫描较大图像的较小区域来解决定位问题，进而在同一图像的不同尺度下重复扫描。</p>
<p>使用这种方法进行目标检测会出现一个问题：区域重叠，针对区域重叠问题，我们可以利用非极大值抑制(详细内容可以参考<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/zyly/p/9245451.html" target="_blank">第二十七节，IOU和非极大值抑制</a>)，来消除重叠的窗口。</p>
<div style="text-align: right;"><a href="https://www.cnblogs.com/zyly/p/9651261.html#_labelTop" style="color:#f68a33">回到顶部</a><a name="_label4"></a></div><h3>五 使用opencv检测人</h3>
<p>下面我们介绍使用OpenCV自带的HOGDescriptor()函数对人进行检测：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008000;">#</span><span style="color: #008000;"> -*- coding: utf-8 -*-</span>
<span style="color: #800000;">"""</span><span style="color: #800000;">
Created on Mon Sep 24 16:43:37 2018

@author: zy
</span><span style="color: #800000;">"""</span>

<span style="color: #800000;">'''</span><span style="color: #800000;">
HOG检测人
</span><span style="color: #800000;">'''</span>
<span style="color: #0000ff;">import</span><span style="color: #000000;">  cv2
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> numpy as np

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> is_inside(o,i):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    判断矩形o是不是在i矩形中
    
    args:
        o：矩形o  (x,y,w,h)
        i：矩形i  (x,y,w,h)
    </span><span style="color: #800000;">'''</span><span style="color: #000000;">
    ox,oy,ow,oh </span>=<span style="color: #000000;"> o
    ix,iy,iw,ih </span>=<span style="color: #000000;"> i
    </span><span style="color: #0000ff;">return</span> ox &gt; ix <span style="color: #0000ff;">and</span> oy &gt; iy <span style="color: #0000ff;">and</span> ox+ow &lt; ix+iw <span style="color: #0000ff;">and</span> oy+oh &lt; iy+<span style="color: #000000;">ih
    
</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> draw_person(img,person):
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    在img图像上绘制矩形框person
    
    args:
        img：图像img
        person：人所在的边框位置 (x,y,w,h)
    </span><span style="color: #800000;">'''</span><span style="color: #000000;">
    x,y,w,h </span>=<span style="color: #000000;"> person
    cv2.rectangle(img,(x,y),(x</span>+w,y+h),(0,255,255),2<span style="color: #000000;">)
    

</span><span style="color: #0000ff;">def</span><span style="color: #000000;"> detect_test():
    </span><span style="color: #800000;">'''</span><span style="color: #800000;">
    检测人
    </span><span style="color: #800000;">'''</span><span style="color: #000000;">
    img </span>= cv2.imread(<span style="color: #800000;">'</span><span style="color: #800000;">./image/person.jpg</span><span style="color: #800000;">'</span><span style="color: #000000;">)
    rows,cols </span>= img.shape[:2<span style="color: #000000;">]
    sacle </span>= 1.0
    <span style="color: #008000;">#</span><span style="color: #008000;">print('img',img.shape)</span>
    img = cv2.resize(img,dsize=(int(cols*sacle),int(rows*<span style="color: #000000;">sacle)))
    </span><span style="color: #008000;">#</span><span style="color: #008000;">print('img',img.shape)</span>
    
    <span style="color: #008000;">#</span><span style="color: #008000;">创建HOG描述符对象</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">计算一个检测窗口特征向量维度：(64/8 - 1)*(128/8 - 1)*4*9 = 3780</span>
    <span style="color: #800000;">'''</span><span style="color: #800000;">
    winSize = (64,128)
    blockSize = (16,16)    
    blockStride = (8,8)
    cellSize = (8,8)
    nbins = 9    
    hog = cv2.HOGDescriptor(winSize,blockSize,blockStride,cellSize,nbins)  
    </span><span style="color: #800000;">'''</span><span style="color: #000000;">
    hog </span>=<span style="color: #000000;"> cv2.HOGDescriptor()  
    </span><span style="color: #008000;">#</span><span style="color: #008000;">hist = hog.compute(img[0:128,0:64])   计算一个检测窗口的维度</span>
    <span style="color: #008000;">#</span><span style="color: #008000;">print(hist.shape)</span>
    detector =<span style="color: #000000;"> cv2.HOGDescriptor_getDefaultPeopleDetector()
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">detector</span><span style="color: #800000;">'</span><span style="color: #000000;">,type(detector),detector.shape)    
    hog.setSVMDetector(detector)

    
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;">多尺度检测，found是一个数组，每一个元素都是对应一个矩形，即检测到的目标框</span>
    found,w =<span style="color: #000000;"> hog.detectMultiScale(img)
    </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">found</span><span style="color: #800000;">'</span><span style="color: #000000;">,type(found),found.shape)
    
    </span><span style="color: #008000;">#</span><span style="color: #008000;">过滤一些矩形，如果矩形o在矩形i中，则过滤掉o</span>
    found_filtered =<span style="color: #000000;"> []
    </span><span style="color: #0000ff;">for</span> ri,r <span style="color: #0000ff;">in</span><span style="color: #000000;"> enumerate(found):
        </span><span style="color: #0000ff;">for</span> qi,q <span style="color: #0000ff;">in</span><span style="color: #000000;"> enumerate(found):
            </span><span style="color: #008000;">#</span><span style="color: #008000;">r在q内？</span>
            <span style="color: #0000ff;">if</span> ri != qi <span style="color: #0000ff;">and</span><span style="color: #000000;"> is_inside(r,q):
                </span><span style="color: #0000ff;">break</span>
        <span style="color: #0000ff;">else</span><span style="color: #000000;">:
            found_filtered.append(r)
            
    </span><span style="color: #0000ff;">for</span> person <span style="color: #0000ff;">in</span><span style="color: #000000;"> found_filtered:
        draw_person(img,person)
        
    cv2.imshow(</span><span style="color: #800000;">'</span><span style="color: #800000;">img</span><span style="color: #800000;">'</span><span style="color: #000000;">,img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    
</span><span style="color: #0000ff;">if</span> <span style="color: #800080;">__name__</span>==<span style="color: #800000;">'</span><span style="color: #800000;">__main__</span><span style="color: #800000;">'</span><span style="color: #000000;">:
    detect_test()</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>输出如下：</p>
<p><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180924225416670-696512349.png" alt="" width="602" height="425"></p>
<p>其中有一点我们需要注意，opencv自带的检测器大小是3781维度的，这是因为在默认参数下，我们从$128\times{64}$的检测窗口中提取的特征向量为3780维度,而我们的检测器采用的是支持向量机，最终的检测方法是基于线性判别函数$wx+b=0$。在训练检测器时，当把特征维度为3780的特征送到SVM中训练，得到的$w$维度也为3780，另外还有一个偏置$b$，因此检测器的维度为3781。</p>
<div class="cnblogs_code">
<pre> detector =<span style="color: #000000;"> cv2.HOGDescriptor_getDefaultPeopleDetector()
 </span><span style="color: #0000ff;">print</span>(<span style="color: #800000;">'</span><span style="color: #800000;">detector</span><span style="color: #800000;">'</span>,type(detector),detector.shape)    </pre>
</div>
<p>另外我在啰嗦一下：在训练的时候，我们的正负样本图像默认大小都应该是$128\times{64}$的，然后提取样本图像的HOG特征，也就是3780维度的特征向量，送入到SVM进行训练，最终的目的就是得到这3781维度的检测器。</p>
<p>在测试的时，<span style="color: #000000;">检测窗口(大小为$128\times{64}$)在整个图像的所有位置和尺度上进行扫描，然后提取提取每一个窗口的HOG特征，送入检测器进行判别，最后还需要对输出的金字塔进行非极大值抑制。例如：这里有张图是$720\times{475}$的，我们选$200\times{100}$大小的patch，把这个patch从图片里面抠出来，然后再把大小调整成<span style="color: #000000;">$128\times{64}$，<span style="color: #000000;">计算HOG特征，并送入检测器判别是否包含目标</span></span>。</span></p>
<p><span style="color: #000000;"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180924231940202-1255472471.png" alt="" width="628" height="321"></span></p>
<p>但是当我们想检测其他目标时，比如一辆车这时候高与宽的比可能就不是2:1了，这时候我们就需要修改HOG对象的配置参数：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre>    <span style="color: #008000;">#</span><span style="color: #008000;">计算一个检测窗口特征向量维度：(64-8)/8*(128-8)/8*4*9 = 3780 </span>
    winSize = (64,128<span style="color: #000000;">)
    blockSize </span>= (16,16<span style="color: #000000;">)    
    blockStride </span>= (8,8<span style="color: #000000;">)
    cellSize </span>= (8,8<span style="color: #000000;">)
    nbins </span>= 9<span style="color: #000000;">    
    hog </span>= cv2.HOGDescriptor(winSize,blockSize,blockStride,cellSize,nbins) </pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>上面的是默认参数，针对不同的目标检测我们一般需要修改为适合自己目标大小的参数：</p>
<ul>
<li>winSize：检查窗口大小，一般为blockStride的整数倍；</li>
<li>blockSize：块大小，一般为cellSize的整数倍；</li>
<li>blockStride：块步长，一般为cellSize的整数倍；</li>
<li>cellSize：每一个细胞单元大小；</li>
<li>nbins：每一个细胞单元提取的直方图bin的个数；</li>
</ul>
<p>计算公式：</p>
<p>沿$x$轴块的个数$m = [(winSize_x - blockSize_x)/blockStride_x+1]$向下取整;</p>
<p>沿$y$轴块的个数$n = [(winSize_y - blockSize_y)/blockStride_x+1]$向下取整;</p>
<p>一个block内的特征向量维度为$c = (blockSize_x/cellSize_x) * (blockSize_y/cellSize_y)*nbins$;</p>
<p>那么特征向量维度 $t = m*n* c$</p>
<p>我们再来形象的说明检测窗口的特征向量维度是如何计算的，因为这个很重要：</p>
<p><img style="float: left;" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180925085934462-247070990.png" alt="" width="233" height="226"></p>
<p><img style="float: left;" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180925085956594-1126886763.png" alt="" width="302" height="227"></p>
<p><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/1328274-20180925090116689-1674133999.png" alt="" width="258" height="225"></p>
<p>看明白了吧？如果再不明白，那你再看看上面的原理吧！！！！！</p>
<div style="text-align: right;"><a href="https://www.cnblogs.com/zyly/p/9651261.html#_labelTop" style="color:#f68a33">回到顶部</a><a name="_label5"></a></div><h3>六 总结</h3>
<p><strong>HOG的优点：&nbsp;</strong></p>
<ul>
<li>核心思想是所检测的局部物体外形能够被梯度或边缘方向的分布所描述，HOG能较好地捕捉局部形状信息，对几何和光学变化都有很好的不变性；&nbsp;</li>
<li>HOG是在密集采样的图像块中求取的，在计算得到的HOG特征向量中隐含了该块与检测窗口之间的空间位置关系。</li>
</ul>
<p><strong>HOG的缺陷：&nbsp;</strong></p>
<ul>
<li>很难处理遮挡问题，人体姿势动作幅度过大或物体方向改变也不易检测（这个问题后来在<a href="http://blog.csdn.net/masibuaa/article/details/17924671" rel="nofollow" target="_blank">DPM</a>中采用可变形部件模型的方法得到了改善）；</li>
<li>跟SIFT相比，HOG没有选取主方向，也没有旋转梯度方向直方图，因而本身不具有旋转不变性（较大的方向变化），其旋转不变性是通过采用不同旋转方向的训练样本来实现的；</li>
<li>跟SIFT相比，HOG本身不具有尺度不变性，其尺度不变性是通过缩放检测窗口图像的大小来实现的；</li>
<li>此外，由于梯度的性质，HOG对噪点相当敏感，在实际应用中，在block和cell划分之后，对于得到各个区域，有时候还会做一次高斯平滑去除噪点。</li>
</ul>
<p><strong>参考文章：</strong></p>
<p><strong><a href="https://hal.inria.fr/file/index/docid/548512/filename/hog_cvpr2005.pdf%20" target="_blank">[1]Dalal N, Triggs B. Histograms of oriented gradients for human detection[C]//Computer Vision and Pattern Recognition, 2005. CVPR 2005. IEEE Computer Society Conference on. IEEE, 2005, 1: 886-893.(2016:Google Citation: 14046) </a></strong></p>
<p><strong><a href="https://tel.archives-ouvertes.fr/tel-00390303/document" target="_blank">[2]Dalal N. Finding people in images and videos[D]. Institut National Polytechnique de Grenoble-INPG, 2006.(Google Citation: 337) </a></strong></p>
<p><strong><a href="https://blog.csdn.net/masibuaa/article/details/14056807" target="_blank">[3]HOG：用于人体检测的梯度方向直方图 Histograms of Oriented Gradients for Human Detection(原文翻译)</a></strong></p>
<p><strong><a href="https://www.cnblogs.com/wyuzl/p/6792216.html" target="_blank">[4]<span class="postTitle2">HOG特征（Histogram of Gradient）学习总结</span></a></strong></p>
<p><strong><span class="postTitle2"><a href="https://www.cnblogs.com/qiqibaby/p/5325193.html" target="_blank">[5]<span class="postTitle2">图像处理之gamma校正</span></a></span></strong></p>
<p><strong><a href="https://blog.csdn.net/liulina603/article/details/8291093" target="_blank"><span class="postTitle2"><span class="postTitle2">[6]</span></span>目标检测的图像特征提取之（一）HOG特征</a></strong></p>
<p><strong><a href="https://blog.csdn.net/ppp8300885/article/details/71078555" target="_blank">[7]80行Python实现-HOG梯度特征提取</a></strong></p>
<p><strong><a href="https://www.leiphone.com/news/201708/ZKsGd2JRKr766wEd.html" target="_blank">[8]图像学习之如何理解方向梯度直方图（Histogram Of Gradient）</a></strong></p>
<p><strong><a href="https://www.cnblogs.com/ronny/p/3886013.html" target="_blank">[9]尺度空间理论</a></strong></p>
<p><strong>[10]OpenCV 3计算机视觉</strong></p>
<p><strong><a href="https://blog.csdn.net/qq_26898461/article/details/46786285" target="_blank">[11]OpenCV HOGDescriptor 参数图解</a></strong></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block"><div id="BlogPostCategory">
    分类: 
            <a href="https://www.cnblogs.com/zyly/category/1197792.html" target="_blank">OpenCV</a></div>


    <div id="blog_post_info">
<div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(9651261,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
        <a id="green_channel_follow" onclick="follow(&#39;a5d9dcaa-d980-4c78-4268-08d54dba4453&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/zyly/" target="_blank"><img src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/20180420181655.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/zyly/">大奥特曼打小怪兽</a><br>
            <a href="https://home.cnblogs.com/u/zyly/followees/">关注 - 9</a><br>
            <a href="https://home.cnblogs.com/u/zyly/followers/">粉丝 - 247</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;a5d9dcaa-d980-4c78-4268-08d54dba4453&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(9651261,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">1</span>
    </div>
    <div class="buryit" onclick="votePost(9651261,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>

<script type="text/javascript">
    currentDiggType = 0;
</script></div>
    <div class="clear"></div>
    <div id="post_next_prev">

    <a href="https://www.cnblogs.com/zyly/p/9646201.html" class="p_n_p_prefix">« </a> 上一篇：    <a href="https://www.cnblogs.com/zyly/p/9646201.html" title="发布于 2018-09-15 12:56">第十七节、图像描述符匹配算法、以及目标匹配</a>
    <br>
    <a href="https://www.cnblogs.com/zyly/p/9703614.html" class="p_n_p_prefix">» </a> 下一篇：    <a href="https://www.cnblogs.com/zyly/p/9703614.html" title="发布于 2018-09-30 22:57">第三十七节、人脸检测MTCNN和人脸识别Facenet(附源码)</a>

</div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2018-09-24 22:41</span>&nbsp;<a href="https://www.cnblogs.com/zyly/">大奥特曼打小怪兽</a> 阅读(<span id="post_view_count">8464</span>) 评论(<span id="post_comment_count">1</span>) <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9651261" rel="nofollow"> 编辑</a> <a href="javascript:void(0)" onclick="AddToWz(9651261); return false;">收藏</a>
</div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/highlight.min.js.下載"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 410475, cb_blogApp = 'zyly', cb_blogUserGuid = 'a5d9dcaa-d980-4c78-4268-08d54dba4453';
    var cb_entryId = 9651261, cb_entryCreatedDate = '2018-09-24 22:41', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder">

<div id="comment_pager_top">
    
</div>

<br>
<div class="feedback_area_title">评论列表</div>
<div class="feedbackNoItems"><div class="feedbackNoItems"></div></div>	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;

<span class="comment_actions">
    
    
    
    
</span>


				</div>
				
<a href="https://www.cnblogs.com/zyly/p/9651261.html#4318303" class="layer">#1楼</a>
<a name="4318303" id="comment_anchor_4318303"></a>

        <span id="comment-maxId" style="display:none">4318303</span>
        <span id="comment-maxDate" style="display:none">8/6/2019 11:12:54 AM</span>
 
<span class="comment_date">2019-08-06 11:12</span>

 

            <a id="a_comment_author_4318303" href="https://home.cnblogs.com/u/1727648/" target="_blank">pengrush</a>

			</div>
			<div class="feedbackCon">
				
<div id="comment_body_4318303" class="blog_comment_body">
    img_copy = img[320:320 + height, 570:570 + width][:, :, ::-1]这句代码后面一个中括号是什么意思啊 运行时候这句代码报错
</div>
        <div class="comment_vote">
            <a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(&#39;4318303&#39;, &#39;Digg&#39;, this);">
                支持(0)
            </a>
            <a href="javascript:void(0);" class="comment_burry" onclick="return voteComment(&#39;4318303&#39;, &#39;Bury&#39;, this);">
                反对(0)
            </a>
        </div>
        

			</div>
		</div>

<div id="comment_pager_bottom">
    
</div>


</div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="https://www.cnblogs.com/zyly/p/9651261.html#" onclick="return RefreshPage();">刷新页面</a><a href="https://www.cnblogs.com/zyly/p/9651261.html#top">返回顶部</a></div>
    <div id="comment_form_container"><div class="login_tips">
    注册用户登录后才能发表评论，请 
    <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a>
     或 
    <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，
    <a href="https://www.cnblogs.com/">访问</a> 网站首页。
</div></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-工控&#39;)">【推荐】超50万C++/C#源码: 大型实时仿真组态图形源码</a><br><a href="http://clickc.admaster.com.cn/c/a131575,b3595121,c1705,i0,m101,8a1,8b3,h" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-华为云学生&#39;)">【推荐】华为云·云创校园套餐9元起，小天鹅音箱等你来拿</a><br><a href="http://clickc.admaster.com.cn/c/a131574,b3595115,c1705,i0,m101,8a1,8b3,h" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-华为云微认证&#39;)">【推荐】零基础轻松玩转云上产品，获壕礼加返百元大礼</a><br><a href="https://www.aliyun90.com/" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-aliyun90&#39;)">【推荐】ALIYUN90% | 免认证  9秒注册阿里云  即开即用</a><br></div>
    <div id="opt_under_post"></div>
    <script async="async" src="./第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码) - 大奥特曼打小怪兽 - 博客园_files/gpt.js.下載"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block" style="">
        <div id="div-gpt-ad-1546353474406-0" style="height: 250px; width: 300px;"><div id="google_ads_iframe_/1090369/C1_0__container__" style="border: 0pt none; width: 300px; height: 250px;"></div></div>
    </div>
    <div id="under_post_news"><div class="recomm-block"><b>相关博文：</b><br>·  <a title="目标检测——HOG特征" href="https://www.cnblogs.com/sophia-hxw/p/5684199.html" target="_blank" onclick="clickRecomItmem(5684199)">目标检测——HOG特征</a><br>·  <a title="《实验楼：基于SVM的猫咪图片识别器》实验报告（更新中）" href="https://www.cnblogs.com/danscarlett/p/9661992.html" target="_blank" onclick="clickRecomItmem(9661992)">《实验楼：基于SVM的猫咪图片识别器》实验报告（更新中）</a><br>·  <a title="目标检测的图像特征提取之（一）HOG特征" href="https://www.cnblogs.com/ywsoftware/p/4434334.html" target="_blank" onclick="clickRecomItmem(4434334)">目标检测的图像特征提取之（一）HOG特征</a><br>·  <a title="图像特征--HOG特征" href="https://www.cnblogs.com/bfshm/p/7660426.html" target="_blank" onclick="clickRecomItmem(7660426)">图像特征--HOG特征</a><br>·  <a title="PCL行人检测" href="https://www.cnblogs.com/li-yao7758258/p/6562432.html" target="_blank" onclick="clickRecomItmem(6562432)">PCL行人检测</a><br></div></div>
    <div id="cnblogs_c2" class="c_ad_block" style="">
        <div id="div-gpt-ad-1539008685004-0" style="height: 60px; width: 468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        <div id="google_ads_iframe_/1090369/C2_0__container__" style="border: 0pt none; width: 468px; height: 60px;"></div></div>
    </div>
    <div id="under_post_kb">
<div class="itnews c_ad_block">
    <b>最新 IT 新闻</b>:
    <br>
 ·              <a href="https://news.cnblogs.com/n/629920/" target="_blank">一线丨金山软件第二季度营收18.7亿元 金山云占比达49%</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/629919/" target="_blank">46家华为关联公司被美国列入实体名单：总数已达114家！</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/629918/" target="_blank">这些眼睛为何能完好地保存在化石中?</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/629917/" target="_blank">世界银行发售3380万美元区块链债券</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/629916/" target="_blank">猎豹移动Q2实现净利润4853万 AI收入增长236.2％</a>
            <br>
    » <a href="https://news.cnblogs.com/" title="IT 新闻" target="_blank">更多新闻...</a>
</div></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem"><!--done-->
<h3 class="catListTitle">公告</h3>

<div id="blog-news">
    
    <div id="profile_block">
        昵称：
        <a href="https://home.cnblogs.com/u/zyly/">
            大奥特曼打小怪兽
        </a>
        <br>
        园龄：
        <a href="https://home.cnblogs.com/u/zyly/" title="入园时间：2018-01-30">
            1年6个月
        </a>
        <br>
        粉丝：
        <a href="https://home.cnblogs.com/u/zyly/followers/">
            247
        </a>
        <br>
        关注：
        <a href="https://home.cnblogs.com/u/zyly/followees/">
            9
        </a>
        <div id="p_b_follow">
<a href="javascript:void(0)" onclick="follow(&#39;a5d9dcaa-d980-4c78-4268-08d54dba4453&#39;)">+加关注</a></div>
        <script>getFollowStatus('a5d9dcaa-d980-4c78-4268-08d54dba4453');</script>
    </div>
</div>

</div>

			<div id="blog-calendar" style="">

<table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar" border="0">
    <tbody>
        <tr>
            <td colspan="7">
                <table class="CalTitle" cellspacing="0" border="0">
                    <tbody>
                        <tr>
                            <td class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/07/21&#39;); return false;">&lt;</a>
                            </td>
                            <td align="center">2019年8月</td>
                            <td align="right" class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/09/21&#39;); return false;">&gt;</a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>
        <tr>
                    <th class="CalDayHeader" align="center" abbr="日" scope="col">日</th>
                    <th class="CalDayHeader" align="center" abbr="一" scope="col">一</th>
                    <th class="CalDayHeader" align="center" abbr="二" scope="col">二</th>
                    <th class="CalDayHeader" align="center" abbr="三" scope="col">三</th>
                    <th class="CalDayHeader" align="center" abbr="四" scope="col">四</th>
                    <th class="CalDayHeader" align="center" abbr="五" scope="col">五</th>
                    <th class="CalDayHeader" align="center" abbr="六" scope="col">六</th>
        </tr>
            <tr>
                            <td class="CalOtherMonthDay" align="center">28</td>
                            <td class="CalOtherMonthDay" align="center">29</td>
                            <td class="CalOtherMonthDay" align="center">30</td>
                            <td class="CalOtherMonthDay" align="center">31</td>
                        <td class="" align="center">
                            1
                        </td>
                        <td class="" align="center">
                            2
                        </td>
                    <td class="CalWeekendDay" align="center">
                        3
                    </td>
            </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            4
                        </td>
                            <td class="" align="center">
                                5
                            </td>
                            <td class="" align="center">
                                6
                            </td>
                            <td class="" align="center">
                                7
                            </td>
                            <td class="" align="center">
                                8
                            </td>
                            <td class="" align="center">
                                <a href="https://www.cnblogs.com/zyly/archive/2019/08/09.html"><u>9</u></a>
                            </td>
                        <td class="CalWeekendDay" align="center">
                            10
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            <a href="https://www.cnblogs.com/zyly/archive/2019/08/11.html"><u>11</u></a>
                        </td>
                            <td class="" align="center">
                                <a href="https://www.cnblogs.com/zyly/archive/2019/08/12.html"><u>12</u></a>
                            </td>
                            <td class="" align="center">
                                13
                            </td>
                            <td class="" align="center">
                                14
                            </td>
                            <td class="" align="center">
                                15
                            </td>
                            <td class="" align="center">
                                16
                            </td>
                        <td class="CalWeekendDay" align="center">
                            17
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            18
                        </td>
                            <td class="" align="center">
                                19
                            </td>
                            <td class="" align="center">
                                20
                            </td>
                            <td class="CalTodayDay" align="center">
                                21
                            </td>
                            <td class="" align="center">
                                22
                            </td>
                            <td class="" align="center">
                                23
                            </td>
                        <td class="CalWeekendDay" align="center">
                            24
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            25
                        </td>
                            <td class="" align="center">
                                26
                            </td>
                            <td class="" align="center">
                                27
                            </td>
                            <td class="" align="center">
                                28
                            </td>
                            <td class="" align="center">
                                29
                            </td>
                            <td class="" align="center">
                                30
                            </td>
                        <td class="CalWeekendDay" align="center">
                            31
                        </td>
                </tr>
                <tr>
                        <td class="CalOtherMonthDay" align="center">
                            1
                        </td>
                            <td class="CalOtherMonthDay" align="center">
                                2
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                3
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                4
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                5
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                6
                            </td>
                        <td class="CalOtherMonthDay" align="center">
                            7
                        </td>
                </tr>
    </tbody>
</table></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn">

<!-- 搜索 -->
<div id="sidebar_search" class="sidebar-block">
    <div id="sidebar_search" class="mySearch">
        <h3 class="catListTitle">搜索</h3>
        <div id="sidebar_search_box">
            <div id="widget_my_zzk" class="div_my_zzk">
                <input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk">
            </div>
            <div id="widget_my_google" class="div_my_zzk">
                <input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk">
            </div>
        </div>
    </div>
</div>

<!-- 常用链接 -->
<div id="sidebar_shortcut" class="sidebar-block">
    <div class="catListLink">
<h3 class="catListTitle">
常用链接
</h3>
<ul>
		<li>

<a href="https://www.cnblogs.com/zyly/p/" title="我的博客的随笔列表">我的随笔</a>
</li>
		<li>

<a href="https://www.cnblogs.com/zyly/MyComments.html" title="我的发表过的评论列表">我的评论</a>
</li>
		<li>

<a href="https://www.cnblogs.com/zyly/OtherPosts.html" title="我评论过的随笔列表">我的参与</a>
</li>
		<li>

<a href="https://www.cnblogs.com/zyly/RecentComments.html" title="我的博客的评论列表">最新评论</a>
</li>
		<li>

<a href="https://www.cnblogs.com/zyly/tag/" title="我的博客的标签列表">我的标签</a>
</li>

</ul>
<div id="itemListLin_con" style="display:none;">
<ul>

</ul>
</div>
</div>


</div>

<!-- 最新随笔 -->



<!-- 我的标签 -->
<div id="sidebar_toptags" class="sidebar-block">
    
</div>

<!-- 积分与排名 -->


<!-- 随笔分类、随笔档案、文章分类、新闻分类、相册、链接 -->
<div id="sidebar_categories">
    
        <div id="sidebar_postcategory" class="catListPostCategory sidebar-block">
            <h3 class="catListTitle">
                

随笔分类



            </h3>


            <ul>

                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1421137.html" rel="">
    Java基本语法(14)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1197792.html" rel="">
    OpenCV(20)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1184392.html" rel="">
    python(3)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1455259.html" rel="">
    Spring MVC(15)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1189958.html" rel="">
    tensorflow(22)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1184391.html" rel="">
    theano使用(4)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1506570.html" rel="">
    大数据(3)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1181468.html" rel="">
    机器学习(3)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1190602.html" rel="">
    精典博客系列收藏(6)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1269242.html" rel="">
    面试题(1)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1180152.html" rel="">
    深度学习(37)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/category/1369315.html" rel="">
    信号处理(1)
</a>
 

                        </li>

            </ul>


        </div>
        <div id="sidebar_postarchive" class="catListPostArchive sidebar-block">
            <h3 class="catListTitle">
                

随笔档案



            </h3>


            <ul>

                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2019/08.html" rel="">
    2019年8月(3)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2019/06.html" rel="">
    2019年6月(1)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2019/05.html" rel="">
    2019年5月(13)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2019/04.html" rel="">
    2019年4月(9)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2019/03.html" rel="">
    2019年3月(6)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2019/01.html" rel="">
    2019年1月(1)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/10.html" rel="">
    2018年10月(2)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/09.html" rel="">
    2018年9月(6)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/08.html" rel="">
    2018年8月(11)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/07.html" rel="">
    2018年7月(14)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/06.html" rel="">
    2018年6月(9)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/05.html" rel="">
    2018年5月(16)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/04.html" rel="">
    2018年4月(23)
</a>
 

                        </li>
                        <li>
                            
<a href="https://www.cnblogs.com/zyly/archive/2018/03.html" rel="">
    2018年3月(14)
</a>
 

                        </li>

            </ul>


        </div>

</div>

<!-- 最新评论 -->
<div id="sidebar_recentcomments" class="sidebar-block">
    <div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div class="RecentCommentBlock">
        <ul>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/zyly/p/9703614.html#4331666">1. Re:第三十七节、人脸检测MTCNN和人脸识别Facenet(附源码)</a></li>
                    <li class="recent_comment_body">你好，我想问一下为什么我的src/train_softmax.py运行速度这么慢，而且数据和您的相差那么大Epoch: [1][503/1000] Time 8.238 Loss 9.701 Xent...</li>
                    <li class="recent_comment_author">--simple6x</li>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/zyly/p/9366080.html#4329965">2. Re:第六节、双目视觉之相机标定</a></li>
                    <li class="recent_comment_body">博主真是牛B,感觉样样精通，从程序开发到人工智能图像识别。</li>
                    <li class="recent_comment_author">--海大富</li>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/zyly/p/9078786.html#4318674">3. Re:第十九节，去噪自编码和栈式自编码</a></li>
                    <li class="recent_comment_body">博主，我刚刚了解tensorflow，想问一下为什么第二层的去噪效果还不如第一的呀？</li>
                    <li class="recent_comment_author">--Sir蓝天</li>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/zyly/p/9651261.html#4318303">4. Re:第十八节、基于传统图像处理的目标检测与识别(HOG+SVM附代码)</a></li>
                    <li class="recent_comment_body">img_copy = img[320:320 + height, 570:570 + width][:, :, ::-1]这句代码后面一个中括号是什么意思啊 运行时候这句代码报错</li>
                    <li class="recent_comment_author">--pengrush</li>
                    <li class="recent_comment_title"><a href="https://www.cnblogs.com/zyly/p/9259392.html#4317885">5. Re:第三十三节，目标检测之选择性搜索-Selective Search</a></li>
                    <li class="recent_comment_body">请问：关于这个函数def _merge_regions(r1, r2): ''' 合并两个候选区域 args: r1：候选区域1 r2：候选区域2 return： 返回合并后的候选区域rt ''' n...</li>
                    <li class="recent_comment_author">--Elvirangela</li>
        </ul>
    </div>
</div>


</div>



<!-- 阅读排行榜 -->
<div id="sidebar_topviewedposts" class="sidebar-block">
    <div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock">
        <ul style="word-break:break-all">
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9029591.html">
                            1. 第二十一节，使用TensorFlow实现LSTM和GRU网络(16591)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9248394.html">
                            2. 第三十二节，使用谷歌Object Detection API进行目标检测、训练新的模型(使用VOC 2012数据集)(16426)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9703614.html">
                            3. 第三十七节、人脸检测MTCNN和人脸识别Facenet(附源码)(13161)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9259392.html">
                            4. 第三十三节，目标检测之选择性搜索-Selective Search(12377)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9366080.html">
                            5. 第六节、双目视觉之相机标定(11343)
                        </a>
                    </li>
        </ul>
    </div>
</div>


</div>

<!-- 评论排行榜 -->
<div id="sidebar_topcommentedposts" class="sidebar-block">
    <div class="catListFeedback">
<h3 class="catListTitle">评论排行榜</h3>
	<div id="TopFeedbackPostsBlock">
        <ul style="word-break:break-all">
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9078786.html">
                            1. 第十九节，去噪自编码和栈式自编码(18)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9703614.html">
                            2. 第三十七节、人脸检测MTCNN和人脸识别Facenet(附源码)(10)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9248394.html">
                            3. 第三十二节，使用谷歌Object Detection API进行目标检测、训练新的模型(使用VOC 2012数据集)(10)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9534063.html">
                            4. 第三十六节，目标检测之yolo源码解析(9)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/zyly/p/9267426.html">
                            5. 第三十四节，目标检测之谷歌Object Detection API源码解析(8)
                        </a>
                    </li>
        </ul>
    </div>
</div>


</div>

<!-- 推荐排行榜 -->
<div id="sidebar_topdiggedposts" class="sidebar-block">
    
<div id="topdigg_posts_wrap">
    <div class="catListView">
        <h3 class="catListTitle">推荐排行榜</h3>
        <div id="TopDiggPostsBlock">
            <ul style="word-break: break-all">
                        <li>
                            <a href="https://www.cnblogs.com/zyly/p/8682794.html">
                                1. 第一节，TensorFlow基本用法(4)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/zyly/p/9029591.html">
                                2. 第二十一节，使用TensorFlow实现LSTM和GRU网络(3)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/zyly/p/9519011.html">
                                3. 第十二节、尺度不变特征(SIFT)(3)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/zyly/p/9373991.html">
                                4. 第七节、双目视觉之空间坐标计算(3)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/zyly/p/9259392.html">
                                5. 第三十三节，目标检测之选择性搜索-Selective Search(2)
                            </a>
                        </li>
            </ul>
        </div>
    </div>
</div>
</div></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright © 2019 大奥特曼打小怪兽
    <div id="poweredby">Powered by .NET Core 3.0 Preview 8 on Linux</div>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <script language="javascript" type="text/javascript">
// 生成目录索引列表
// ref: http://www.cnblogs.com/wangqiguo/p/4355032.html
// modified by: zzq
function GenerateContentList()
{
    var mainContent = $('#cnblogs_post_body');
    var h2_list = $('#cnblogs_post_body h3');//如果你的章节标题不是h3,只需要将这里的h3换掉即可

    if(mainContent.length < 1)
        return;
 
    if(h2_list.length>0)
    {
        var content = '<a name="_labelTop"></a>';
        content += '<div id="navCategory" style="color:#152e97;">';
        content += '<p style="font-size:18px;"><b>目录</b></p>';
        content += '<ul>';
        for(var i=0; i<h2_list.length; i++)
        {
            var go_to_top = '<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33">回到顶部</a><a name="_label' + i + '"></a></div>';
            $(h2_list[i]).before(go_to_top);
            
            var h3_list = $(h2_list[i]).nextAll("h4");
            var li3_content = '';
            for(var j=0; j<h3_list.length; j++)
            {
                var tmp = $(h3_list[j]).prevAll('h3').first();
                if(!tmp.is(h2_list[i]))
                    break;
                var li3_anchor = '<a name="_label' + i + '_' + j + '"></a>';
                $(h3_list[j]).before(li3_anchor);
                li3_content += '<li><a href="#_label' + i + '_' + j + '">' + $(h3_list[j]).text() + '</a></li>';
            }
            
            var li2_content = '';
            if(li3_content.length > 0)
                li2_content = '<li><a href="#_label' + i + '">' + $(h2_list[i]).text() + '</a><ul>' + li3_content + '</ul></li>';
            else
                li2_content = '<li><a href="#_label' + i + '">' + $(h2_list[i]).text() + '</a></li>';
            content += li2_content;
        }
        content += '</ul>';
        content += '</div><p>&nbsp;</p>';
        content += '<hr style="height:1px;border:none;border-top:1px dashed #0066CC;"/>';
        if($('#cnblogs_post_body').length != 0 )
        {
            $($('#cnblogs_post_body')[0]).prepend(content);
        }
    }   
}

GenerateContentList();
</script>
    </div>


</body></html>